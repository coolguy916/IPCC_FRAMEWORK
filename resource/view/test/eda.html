<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated EDA Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50, #3498db);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .controls {
            padding: 30px;
            background: #f8f9fa;
            border-bottom: 1px solid #e9ecef;
        }

        .control-group {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .file-input {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

        .file-input input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            padding: 12px 25px;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            font-size: 14px;
            font-weight: 600;
        }

        .file-input-label:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.4);
        }

        select, button {
            padding: 12px 20px;
            border: 2px solid #ddd;
            border-radius: 25px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
        }

        select:focus, button:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        button {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.4);
        }

        .main-content {
            padding: 30px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #ffffff, #f8f9fa);
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
            transition: transform 0.3s ease;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.15);
        }

        .stat-card h3 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .stat-value {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 10px;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: white;
            padding: 25px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
        }

        .chart-container h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.3em;
        }

        .data-table-container {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 1px solid #e9ecef;
            overflow: hidden;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            overflow-x: auto;
        }

        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e9ecef;
        }

        .data-table th {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            font-weight: 600;
            position: sticky;
            top: 0;
        }

        .data-table tr:hover {
            background-color: #f8f9fa;
        }

        .loading {
            text-align: center;
            padding: 50px;
            font-size: 1.2em;
            color: #7f8c8d;
        }

        .error {
            background: #e74c3c;
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        @media (max-width: 768px) {
            .control-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Automated EDA Tool</h1>
            <p>Advanced Object-Oriented Exploratory Data Analysis</p>
        </div>

        <div class="controls">
            <div class="control-group">
                <div class="file-input">
                    <input type="file" id="csvFile" accept=".csv">
                    <label for="csvFile" class="file-input-label">üìÅ Upload CSV File</label>
                </div>
                
                <select id="analysisType">
                    <option value="basic">Basic Analysis</option>
                    <option value="advanced">Advanced Analysis</option>
                    <option value="correlation">Correlation Analysis</option>
                </select>

                <select id="chartType">
                    <option value="all">All Charts</option>
                    <option value="histogram">Histograms Only</option>
                    <option value="scatter">Scatter Plots Only</option>
                    <option value="bar">Bar Charts Only</option>
                </select>

                <button onclick="generateSampleData()">üé≤ Generate Sample Data</button>
                <button onclick="clearAnalysis()">üóëÔ∏è Clear Analysis</button>
            </div>
        </div>

        <div class="main-content">
            <div id="errorContainer"></div>
            <div id="loadingContainer"></div>
            <div id="statsContainer" class="stats-grid"></div>
            <div id="chartsContainer" class="charts-grid"></div>
            <div id="tableContainer"></div>
        </div>
    </div>

    <script>
        // Core EDA Classes

        class DataProcessor {
            constructor() {
                this.data = null;
                this.columns = [];
                this.numericColumns = [];
                this.categoricalColumns = [];
                this.stats = {};
            }

            loadData(csvData) {
                try {
                    const parsed = Papa.parse(csvData, {
                        header: true,
                        dynamicTyping: true,
                        skipEmptyLines: true
                    });
                    
                    this.data = parsed.data;
                    this.columns = parsed.meta.fields || [];
                    this.analyzeColumns();
                    return true;
                } catch (error) {
                    console.error('Data loading error:', error);
                    return false;
                }
            }

            analyzeColumns() {
                this.numericColumns = [];
                this.categoricalColumns = [];

                this.columns.forEach(col => {
                    const sample = this.data.slice(0, 100).map(row => row[col]).filter(val => val != null);
                    const numericCount = sample.filter(val => !isNaN(val) && typeof val === 'number').length;
                    
                    if (numericCount > sample.length * 0.7) {
                        this.numericColumns.push(col);
                    } else {
                        this.categoricalColumns.push(col);
                    }
                });
            }

            calculateBasicStats() {
                const stats = {
                    totalRows: this.data.length,
                    totalColumns: this.columns.length,
                    numericColumns: this.numericColumns.length,
                    categoricalColumns: this.categoricalColumns.length,
                    missingValues: 0
                };

                // Calculate missing values
                this.data.forEach(row => {
                    this.columns.forEach(col => {
                        if (row[col] == null || row[col] === '') {
                            stats.missingValues++;
                        }
                    });
                });

                return stats;
            }

            calculateAdvancedStats() {
                const advanced = {};
                
                this.numericColumns.forEach(col => {
                    const values = this.data.map(row => row[col]).filter(val => val != null && !isNaN(val));
                    if (values.length > 0) {
                        values.sort((a, b) => a - b);
                        const n = values.length;
                        
                        advanced[col] = {
                            mean: values.reduce((a, b) => a + b, 0) / n,
                            median: n % 2 === 0 ? (values[n/2-1] + values[n/2]) / 2 : values[Math.floor(n/2)],
                            min: Math.min(...values),
                            max: Math.max(...values),
                            std: this.calculateStandardDeviation(values),
                            q25: values[Math.floor(n * 0.25)],
                            q75: values[Math.floor(n * 0.75)]
                        };
                    }
                });

                return advanced;
            }

            calculateStandardDeviation(values) {
                const mean = values.reduce((a, b) => a + b, 0) / values.length;
                const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
                return Math.sqrt(variance);
            }

            calculateCorrelations() {
                const correlations = {};
                
                for (let i = 0; i < this.numericColumns.length; i++) {
                    for (let j = i + 1; j < this.numericColumns.length; j++) {
                        const col1 = this.numericColumns[i];
                        const col2 = this.numericColumns[j];
                        
                        const correlation = this.pearsonCorrelation(col1, col2);
                        correlations[`${col1}_${col2}`] = correlation;
                    }
                }
                
                return correlations;
            }

            pearsonCorrelation(col1, col2) {
                const pairs = this.data.map(row => [row[col1], row[col2]])
                    .filter(pair => !isNaN(pair[0]) && !isNaN(pair[1]) && pair[0] != null && pair[1] != null);
                
                if (pairs.length < 2) return 0;
                
                const n = pairs.length;
                const sum1 = pairs.reduce((sum, pair) => sum + pair[0], 0);
                const sum2 = pairs.reduce((sum, pair) => sum + pair[1], 0);
                const sum1Sq = pairs.reduce((sum, pair) => sum + pair[0] * pair[0], 0);
                const sum2Sq = pairs.reduce((sum, pair) => sum + pair[1] * pair[1], 0);
                const pSum = pairs.reduce((sum, pair) => sum + pair[0] * pair[1], 0);
                
                const num = pSum - (sum1 * sum2 / n);
                const den = Math.sqrt((sum1Sq - sum1 * sum1 / n) * (sum2Sq - sum2 * sum2 / n));
                
                return den === 0 ? 0 : num / den;
            }

            getColumnData(column) {
                return this.data.map(row => row[column]).filter(val => val != null);
            }

            getFrequencyData(column) {
                const values = this.getColumnData(column);
                const frequency = {};
                
                values.forEach(val => {
                    frequency[val] = (frequency[val] || 0) + 1;
                });
                
                return frequency;
            }
        }

        class ChartGenerator {
            constructor() {
                this.charts = {};
            }

            createHistogram(containerId, data, title) {
                const ctx = document.getElementById(containerId);
                if (!ctx) return;

                const bins = this.createBins(data, 20);
                
                if (this.charts[containerId]) {
                    this.charts[containerId].destroy();
                }

                this.charts[containerId] = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: bins.map(bin => bin.range),
                        datasets: [{
                            label: 'Frequency',
                            data: bins.map(bin => bin.count),
                            backgroundColor: 'rgba(52, 152, 219, 0.7)',
                            borderColor: 'rgba(52, 152, 219, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: title
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            createScatterPlot(containerId, xData, yData, xLabel, yLabel) {
                const ctx = document.getElementById(containerId);
                if (!ctx) return;

                const data = xData.map((x, i) => ({ x, y: yData[i] }))
                    .filter(point => !isNaN(point.x) && !isNaN(point.y));

                if (this.charts[containerId]) {
                    this.charts[containerId].destroy();
                }

                this.charts[containerId] = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [{
                            label: `${xLabel} vs ${yLabel}`,
                            data: data,
                            backgroundColor: 'rgba(231, 76, 60, 0.6)',
                            borderColor: 'rgba(231, 76, 60, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: `${xLabel} vs ${yLabel}`
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: xLabel
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: yLabel
                                }
                            }
                        }
                    }
                });
            }

            createBarChart(containerId, labels, data, title) {
                const ctx = document.getElementById(containerId);
                if (!ctx) return;

                if (this.charts[containerId]) {
                    this.charts[containerId].destroy();
                }

                this.charts[containerId] = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Count',
                            data: data,
                            backgroundColor: 'rgba(155, 89, 182, 0.7)',
                            borderColor: 'rgba(155, 89, 182, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: title
                            }
                        },
                        scales: {
                            y: {
                                beginAtZero: true
                            }
                        }
                    }
                });
            }

            createBins(data, numBins) {
                const min = Math.min(...data);
                const max = Math.max(...data);
                const binSize = (max - min) / numBins;
                const bins = [];

                for (let i = 0; i < numBins; i++) {
                    const binStart = min + i * binSize;
                    const binEnd = binStart + binSize;
                    const count = data.filter(val => val >= binStart && val < binEnd).length;
                    
                    bins.push({
                        range: `${binStart.toFixed(1)}-${binEnd.toFixed(1)}`,
                        count: count
                    });
                }

                return bins;
            }

            destroyAllCharts() {
                Object.values(this.charts).forEach(chart => chart.destroy());
                this.charts = {};
            }
        }

        class UIManager {
            constructor() {
                this.statsContainer = document.getElementById('statsContainer');
                this.chartsContainer = document.getElementById('chartsContainer');
                this.tableContainer = document.getElementById('tableContainer');
                this.errorContainer = document.getElementById('errorContainer');
                this.loadingContainer = document.getElementById('loadingContainer');
            }

            showLoading() {
                this.loadingContainer.innerHTML = '<div class="loading">üîÑ Processing data...</div>';
            }

            hideLoading() {
                this.loadingContainer.innerHTML = '';
            }

            showError(message) {
                this.errorContainer.innerHTML = `<div class="error">‚ùå ${message}</div>`;
            }

            clearError() {
                this.errorContainer.innerHTML = '';
            }

            displayStats(stats) {
                const statsHTML = Object.entries(stats).map(([key, value]) => `
                    <div class="stat-card">
                        <h3>${this.formatStatName(key)}</h3>
                        <div class="stat-value">${typeof value === 'number' ? value.toLocaleString() : value}</div>
                    </div>
                `).join('');
                
                this.statsContainer.innerHTML = statsHTML;
            }

            displayAdvancedStats(stats) {
                const statsHTML = Object.entries(stats).map(([column, columnStats]) => `
                    <div class="stat-card">
                        <h3>${column}</h3>
                        ${Object.entries(columnStats).map(([stat, value]) => 
                            `<div><strong>${stat}:</strong> ${typeof value === 'number' ? value.toFixed(2) : value}</div>`
                        ).join('')}
                    </div>
                `).join('');
                
                this.statsContainer.innerHTML = statsHTML;
            }

            displayCorrelations(correlations) {
                const correlationsHTML = Object.entries(correlations).map(([pair, correlation]) => {
                    const [col1, col2] = pair.split('_');
                    const strength = Math.abs(correlation) > 0.7 ? 'Strong' : 
                                   Math.abs(correlation) > 0.5 ? 'Moderate' : 'Weak';
                    return `
                        <div class="stat-card">
                            <h3>${col1} ‚Üî ${col2}</h3>
                            <div class="stat-value">${correlation.toFixed(3)}</div>
                            <div>${strength} correlation</div>
                        </div>
                    `;
                }).join('');
                
                this.statsContainer.innerHTML = correlationsHTML;
            }

            createChartContainers(charts) {
                this.chartsContainer.innerHTML = charts.map(chart => `
                    <div class="chart-container">
                        <h3>${chart.title}</h3>
                        <canvas id="${chart.id}" width="400" height="300"></canvas>
                    </div>
                `).join('');
            }

            displayDataTable(data, columns) {
                const maxRows = 100; // Limit display for performance
                const displayData = data.slice(0, maxRows);
                
                const tableHTML = `
                    <div class="data-table-container">
                        <h3>üìä Data Preview (First ${Math.min(maxRows, data.length)} rows)</h3>
                        <div style="overflow-x: auto;">
                            <table class="data-table">
                                <thead>
                                    <tr>
                                        ${columns.map(col => `<th>${col}</th>`).join('')}
                                    </tr>
                                </thead>
                                <tbody>
                                    ${displayData.map(row => `
                                        <tr>
                                            ${columns.map(col => `<td>${row[col] ?? 'N/A'}</td>`).join('')}
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                    </div>
                `;
                
                this.tableContainer.innerHTML = tableHTML;
            }

            formatStatName(name) {
                return name.replace(/([A-Z])/g, ' $1')
                          .replace(/^./, str => str.toUpperCase());
            }

            clear() {
                this.statsContainer.innerHTML = '';
                this.chartsContainer.innerHTML = '';
                this.tableContainer.innerHTML = '';
                this.clearError();
                this.hideLoading();
            }
        }

        // Main EDA Application
        class AutomatedEDA {
            constructor() {
                this.dataProcessor = new DataProcessor();
                this.chartGenerator = new ChartGenerator();
                this.uiManager = new UIManager();
                this.currentAnalysisType = 'basic';
                this.currentChartType = 'all';
                
                this.bindEvents();
            }

            bindEvents() {
                document.getElementById('csvFile').addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        this.loadFile(e.target.files[0]);
                    }
                });

                document.getElementById('analysisType').addEventListener('change', (e) => {
                    this.currentAnalysisType = e.target.value;
                    if (this.dataProcessor.data) {
                        this.runAnalysis();
                    }
                });

                document.getElementById('chartType').addEventListener('change', (e) => {
                    this.currentChartType = e.target.value;
                    if (this.dataProcessor.data) {
                        this.generateCharts();
                    }
                });
            }

            async loadFile(file) {
                this.uiManager.showLoading();
                this.uiManager.clearError();

                try {
                    const text = await this.readFileAsText(file);
                    const success = this.dataProcessor.loadData(text);
                    
                    if (success) {
                        this.runAnalysis();
                        this.uiManager.displayDataTable(this.dataProcessor.data, this.dataProcessor.columns);
                    } else {
                        this.uiManager.showError('Failed to parse CSV file');
                    }
                } catch (error) {
                    this.uiManager.showError('Error reading file: ' + error.message);
                } finally {
                    this.uiManager.hideLoading();
                }
            }

            readFileAsText(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = e => resolve(e.target.result);
                    reader.onerror = reject;
                    reader.readAsText(file);
                });
            }

            runAnalysis() {
                if (!this.dataProcessor.data) return;

                switch (this.currentAnalysisType) {
                    case 'basic':
                        const basicStats = this.dataProcessor.calculateBasicStats();
                        this.uiManager.displayStats(basicStats);
                        break;
                        
                    case 'advanced':
                        const advancedStats = this.dataProcessor.calculateAdvancedStats();
                        this.uiManager.displayAdvancedStats(advancedStats);
                        break;
                        
                    case 'correlation':
                        const correlations = this.dataProcessor.calculateCorrelations();
                        this.uiManager.displayCorrelations(correlations);
                        break;
                }

                this.generateCharts();
            }

            generateCharts() {
                if (!this.dataProcessor.data) return;

                const charts = [];
                
                // Generate histograms for numeric columns
                if (this.currentChartType === 'all' || this.currentChartType === 'histogram') {
                    this.dataProcessor.numericColumns.slice(0, 4).forEach((col, index) => {
                        charts.push({
                            id: `histogram_${index}`,
                            title: `Distribution of ${col}`,
                            type: 'histogram',
                            column: col
                        });
                    });
                }

                // Generate scatter plots
                if (this.currentChartType === 'all' || this.currentChartType === 'scatter') {
                    if (this.dataProcessor.numericColumns.length >= 2) {
                        for (let i = 0; i < Math.min(2, this.dataProcessor.numericColumns.length - 1); i++) {
                            charts.push({
                                id: `scatter_${i}`,
                                title: `${this.dataProcessor.numericColumns[i]} vs ${this.dataProcessor.numericColumns[i + 1]}`,
                                type: 'scatter',
                                xColumn: this.dataProcessor.numericColumns[i],
                                yColumn: this.dataProcessor.numericColumns[i + 1]
                            });
                        }
                    }
                }

                // Generate bar charts for categorical columns
                if (this.currentChartType === 'all' || this.currentChartType === 'bar') {
                    this.dataProcessor.categoricalColumns.slice(0, 2).forEach((col, index) => {
                        charts.push({
                            id: `bar_${index}`,
                            title: `Count of ${col}`,
                            type: 'bar',
                            column: col
                        });
                    });
                }

                this.uiManager.createChartContainers(charts);

                // Create the actual charts
                setTimeout(() => {
                    charts.forEach(chart => {
                        switch (chart.type) {
                            case 'histogram':
                                const data = this.dataProcessor.getColumnData(chart.column)
                                    .filter(val => !isNaN(val));
                                this.chartGenerator.createHistogram(chart.id, data, chart.title);
                                break;
                                
                            case 'scatter':
                                const xData = this.dataProcessor.getColumnData(chart.xColumn);
                                const yData = this.dataProcessor.getColumnData(chart.yColumn);
                                this.chartGenerator.createScatterPlot(chart.id, xData, yData, chart.xColumn, chart.yColumn);
                                break;
                                
                            case 'bar':
                                const frequency = this.dataProcessor.getFrequencyData(chart.column);
                                const topEntries = Object.entries(frequency)
                                    .sort(([,a], [,b]) => b - a)
                                    .slice(0, 10);
                                this.chartGenerator.createBarChart(
                                    chart.id,
                                    topEntries.map(([label]) => label),
                                    topEntries.map(([, count]) => count),
                                    chart.title
                                );
                                break;
                        }
                    });
                }, 100);
            }

            clear() {
                this.dataProcessor.data = null;
                this.dataProcessor.columns = [];
                this.chartGenerator.destroyAllCharts();
                this.uiManager.clear();
                document.getElementById('csvFile').value = '';
            }
        }

        // Initialize the application
        const edaApp = new AutomatedEDA();

        // Global functions
        function generateSampleData() {
            const sampleCSV = `Name,Age,Salary,Department,Experience,Rating
John Doe,28,75000,Engineering,5,4.2
Jane Smith,32,85000,Marketing,7,4.5
Bob Johnson,45,95000,Engineering,12,4.8
Alice Brown,29,70000,Sales,4,4.1
Charlie Wilson,38,90000,Marketing,9,4.6
Diana Lee,26,65000,Sales,2,3.9
Frank Miller,41,110000,Engineering,15,4.9
Grace Davis,35,80000,Marketing,8,4.3
Henry Taylor,31,72000,Sales,6,4.0
Ivy Chen,27,68000,Engineering,3,4.4
Jack Anderson,44,105000,Marketing,11,4.7
Karen White,33,78000,Sales,7,4.2
Leo Martinez,39,88000,Engineering,10,4.5
Mia Rodriguez,30,75000,Marketing,5,4.1
Nathan Clark,36,82000,Sales,8,4.3
Olivia Lewis,25,62000,Engineering,1,3.8
Paul Walker,42,98000,Marketing,13,4.6
Quinn Hall,34,79000,Sales,6,4.2
Rachel Young,37,86000,Engineering,9,4.4
Sam King,29,71000,Marketing,4,4.0
Tina Scott,40,92000,Sales,12,4.5
Uma Green,28,69000,Engineering,3,4.1
Victor Adams,43,101000,Marketing,14,4.8
Wendy Baker,31,74000,Sales,5,4.2
Xavier Gonzalez,35,83000,Engineering,8,4.6`
            
            const success = edaApp.dataProcessor.loadData(sampleCSV);
            if (success) {
                edaApp.runAnalysis();
                edaApp.uiManager.displayDataTable(edaApp.dataProcessor.data, edaApp.dataProcessor.columns);
                edaApp.uiManager.clearError();
            } else {
                edaApp.uiManager.showError('Failed to generate sample data');
            }
        }

        function clearAnalysis() {
            edaApp.clear();
        }

        // Additional utility functions for extended functionality
        class DataExporter {
            static exportToPDF(stats, correlations) {
                // This would require additional libraries like jsPDF
                console.log('PDF export functionality would be implemented here');
            }
            
            static exportToJSON(data) {
                const jsonData = {
                    timestamp: new Date().toISOString(),
                    data: data,
                    summary: {
                        rows: data.length,
                        columns: Object.keys(data[0] || {}).length
                    }
                };
                
                const blob = new Blob([JSON.stringify(jsonData, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `eda-export-${Date.now()}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        class StatisticalTests {
            static tTest(sample1, sample2) {
                // Implement t-test for comparing means
                const mean1 = sample1.reduce((a, b) => a + b, 0) / sample1.length;
                const mean2 = sample2.reduce((a, b) => a + b, 0) / sample2.length;
                
                const variance1 = sample1.reduce((sum, val) => sum + Math.pow(val - mean1, 2), 0) / (sample1.length - 1);
                const variance2 = sample2.reduce((sum, val) => sum + Math.pow(val - mean2, 2), 0) / (sample2.length - 1);
                
                const pooledSE = Math.sqrt(variance1/sample1.length + variance2/sample2.length);
                const tStatistic = (mean1 - mean2) / pooledSE;
                
                return {
                    tStatistic,
                    mean1,
                    mean2,
                    pooledSE
                };
            }
            
            static chiSquareTest(observed, expected) {
                // Implement chi-square test for categorical data
                let chiSquare = 0;
                for (let i = 0; i < observed.length; i++) {
                    chiSquare += Math.pow(observed[i] - expected[i], 2) / expected[i];
                }
                return chiSquare;
            }
        }

        // Enhanced DataProcessor with additional methods
        DataProcessor.prototype.detectOutliers = function(column) {
            const values = this.getColumnData(column).filter(val => !isNaN(val));
            if (values.length < 4) return [];
            
            values.sort((a, b) => a - b);
            const q1 = values[Math.floor(values.length * 0.25)];
            const q3 = values[Math.floor(values.length * 0.75)];
            const iqr = q3 - q1;
            const lowerBound = q1 - 1.5 * iqr;
            const upperBound = q3 + 1.5 * iqr;
            
            return values.filter(val => val < lowerBound || val > upperBound);
        };

        DataProcessor.prototype.normalityTest = function(column) {
            // Simple Shapiro-Wilk approximation for small samples
            const values = this.getColumnData(column).filter(val => !isNaN(val));
            if (values.length < 3) return { isNormal: false, pValue: 0 };
            
            values.sort((a, b) => a - b);
            const n = values.length;
            const mean = values.reduce((a, b) => a + b, 0) / n;
            const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / (n - 1);
            
            // Simplified normality check based on skewness and kurtosis
            const skewness = this.calculateSkewness(values, mean, Math.sqrt(variance));
            const kurtosis = this.calculateKurtosis(values, mean, Math.sqrt(variance));
            
            const isNormal = Math.abs(skewness) < 2 && Math.abs(kurtosis - 3) < 2;
            
            return { isNormal, skewness, kurtosis };
        };

        DataProcessor.prototype.calculateSkewness = function(values, mean, std) {
            const n = values.length;
            const skewness = values.reduce((sum, val) => sum + Math.pow((val - mean) / std, 3), 0) / n;
            return skewness;
        };

        DataProcessor.prototype.calculateKurtosis = function(values, mean, std) {
            const n = values.length;
            const kurtosis = values.reduce((sum, val) => sum + Math.pow((val - mean) / std, 4), 0) / n;
            return kurtosis;
        };

        // Enhanced ChartGenerator with additional chart types
        ChartGenerator.prototype.createBoxPlot = function(containerId, data, title) {
            const ctx = document.getElementById(containerId);
            if (!ctx) return;

            const values = data.filter(val => !isNaN(val)).sort((a, b) => a - b);
            const n = values.length;
            
            const q1 = values[Math.floor(n * 0.25)];
            const median = n % 2 === 0 ? (values[n/2-1] + values[n/2]) / 2 : values[Math.floor(n/2)];
            const q3 = values[Math.floor(n * 0.75)];
            const min = Math.min(...values);
            const max = Math.max(...values);

            if (this.charts[containerId]) {
                this.charts[containerId].destroy();
            }

            // Create a simple box plot representation using bar chart
            this.charts[containerId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['Min', 'Q1', 'Median', 'Q3', 'Max'],
                    datasets: [{
                        label: 'Box Plot Values',
                        data: [min, q1, median, q3, max],
                        backgroundColor: [
                            'rgba(255, 99, 132, 0.7)',
                            'rgba(54, 162, 235, 0.7)',
                            'rgba(255, 205, 86, 0.7)',
                            'rgba(75, 192, 192, 0.7)',
                            'rgba(153, 102, 255, 0.7)'
                        ],
                        borderColor: [
                            'rgba(255, 99, 132, 1)',
                            'rgba(54, 162, 235, 1)',
                            'rgba(255, 205, 86, 1)',
                            'rgba(75, 192, 192, 1)',
                            'rgba(153, 102, 255, 1)'
                        ],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        title: {
                            display: true,
                            text: title
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: false
                        }
                    }
                }
            });
        };

        ChartGenerator.prototype.createHeatmap = function(containerId, correlationMatrix, labels) {
            // This would typically require a specialized library
            // For now, we'll create a simple representation
            const ctx = document.getElementById(containerId);
            if (!ctx) return;
            
            console.log('Heatmap visualization would be implemented with specialized charting library');
        };